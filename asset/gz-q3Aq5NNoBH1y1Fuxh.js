var c=Object.defineProperty;var u=(s,t,e)=>t in s?c(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var l=(s,t,e)=>u(s,typeof t!="symbol"?t+"":t,e);const r=class r{constructor(t=0){l(this,"bitfield",BigInt(0));this.bitfield=r.resolve.call(this,t)}any(t){return(this.bitfield&r.resolve.call(this,t))!==BigInt(0)}equals(t){return this.bitfield===r.resolve.call(this,t)}has(t){if(Array.isArray(t))return t.every(i=>this.has(i));const e=r.resolve.call(this,t);return(this.bitfield&e)===e}missing(t){return Array.isArray(t)||(t=new r(t).toArray()),t.filter(e=>!this.has(e))}freeze(){return Object.freeze(this)}add(...t){let e=BigInt(0);for(const i of t)e|=r.resolve.call(this,i);return Object.isFrozen(this)?new r(this.bitfield|e):(this.bitfield|=e,this)}remove(...t){let e=BigInt(0);for(const i of t)e|=r.resolve.call(this,i);return Object.isFrozen(this)?new r(this.bitfield&~e):(this.bitfield&=~e,this)}serialize(){const t={};for(const[e,i]of Object.entries(r.FLAGS))t[e]=this.has(i);return t}toArray(){return Object.keys(r.FLAGS).filter(t=>this.has(t))}toJSON(){return this.bitfield}valueOf(){return this.bitfield}*[Symbol.iterator](){yield*this.toArray()}static resolve(t=BigInt(0)){var i,o;const e=this.FLAGS||((i=this.constructor)==null?void 0:i.FLAGS);if(typeof t=="string"){if(typeof e[t]<"u")return e[t];t=BigInt(t)}if((typeof t=="number"||typeof t=="bigint")&&t>=BigInt(0))return BigInt(t);if(t instanceof r)return t.bitfield;if(Array.isArray(t)){const f=((o=this.constructor)==null?void 0:o.resolve)||this.resolve;return t.map(n=>f.call(this,n)).reduce((n,h)=>BigInt(n)|BigInt(h),BigInt(0))}throw new RangeError("BITFIELD_INVALID: "+t)}};l(r,"FLAGS",{});let a=r;function y(s){return BigInt(1)<<BigInt(s)}export{a as B,y as a};
//# sourceMappingURL=gz-q3Aq5NNoBH1y1Fuxh.js.map
