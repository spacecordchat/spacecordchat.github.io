{"version":3,"file":"gz-q3Aq5NNoBH1y1Fuxh.js","sources":["../../src/utils/BitField.ts"],"sourcesContent":["\"use strict\";\n\n// https://github.com/discordjs/discord.js/blob/master/src/util/BitField.js\n// Apache License Version 2.0 Copyright 2015 - 2021 Amish Shah\n// @fc-license-skip\n\nexport type BitFieldResolvable = number | bigint | BitField | string | BitFieldResolvable[];\n\n/**\n * Data structure that makes it easy to interact with a bitfield.\n */\nexport class BitField {\n\tpublic bitfield = BigInt(0);\n\n\tpublic static FLAGS: Record<string, bigint> = {};\n\n\tconstructor(bits: BitFieldResolvable = 0) {\n\t\tthis.bitfield = BitField.resolve.call(this, bits);\n\t}\n\n\t/**\n\t * Checks whether the bitfield has a bit, or any of multiple bits.\n\t */\n\tany(bit: BitFieldResolvable): boolean {\n\t\treturn (this.bitfield & BitField.resolve.call(this, bit)) !== BigInt(0);\n\t}\n\n\t/**\n\t * Checks if this bitfield equals another\n\t */\n\tequals(bit: BitFieldResolvable): boolean {\n\t\treturn this.bitfield === BitField.resolve.call(this, bit);\n\t}\n\n\t/**\n\t * Checks whether the bitfield has a bit, or multiple bits.\n\t */\n\thas(bit: BitFieldResolvable): boolean {\n\t\tif (Array.isArray(bit)) return bit.every((p) => this.has(p));\n\t\tconst BIT = BitField.resolve.call(this, bit);\n\t\treturn (this.bitfield & BIT) === BIT;\n\t}\n\n\t/**\n\t * Gets all given bits that are missing from the bitfield.\n\t */\n\tmissing(bits: BitFieldResolvable) {\n\t\tif (!Array.isArray(bits)) bits = new BitField(bits).toArray();\n\t\treturn bits.filter((p) => !this.has(p));\n\t}\n\n\t/**\n\t * Freezes these bits, making them immutable.\n\t */\n\tfreeze(): Readonly<BitField> {\n\t\treturn Object.freeze(this);\n\t}\n\n\t/**\n\t * Adds bits to these ones.\n\t * @param {...BitFieldResolvable} [bits] Bits to add\n\t * @returns {BitField} These bits or new BitField if the instance is frozen.\n\t */\n\tadd(...bits: BitFieldResolvable[]): BitField {\n\t\tlet total = BigInt(0);\n\t\tfor (const bit of bits) {\n\t\t\ttotal |= BitField.resolve.call(this, bit);\n\t\t}\n\t\tif (Object.isFrozen(this)) return new BitField(this.bitfield | total);\n\t\tthis.bitfield |= total;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes bits from these.\n\t * @param {...BitFieldResolvable} [bits] Bits to remove\n\t */\n\tremove(...bits: BitFieldResolvable[]) {\n\t\tlet total = BigInt(0);\n\t\tfor (const bit of bits) {\n\t\t\ttotal |= BitField.resolve.call(this, bit);\n\t\t}\n\t\tif (Object.isFrozen(this)) return new BitField(this.bitfield & ~total);\n\t\tthis.bitfield &= ~total;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Gets an object mapping field names to a {@link boolean} indicating whether the\n\t * bit is available.\n\t * @param {...*} hasParams Additional parameters for the has method, if any\n\t */\n\tserialize() {\n\t\tconst serialized: Record<string, boolean> = {};\n\t\tfor (const [flag, bit] of Object.entries(BitField.FLAGS)) serialized[flag] = this.has(bit);\n\t\treturn serialized;\n\t}\n\n\t/**\n\t * Gets an {@link Array} of bitfield names based on the bits available.\n\t */\n\ttoArray(): string[] {\n\t\treturn Object.keys(BitField.FLAGS).filter((bit) => this.has(bit));\n\t}\n\n\ttoJSON() {\n\t\treturn this.bitfield;\n\t}\n\n\tvalueOf() {\n\t\treturn this.bitfield;\n\t}\n\n\t*[Symbol.iterator]() {\n\t\tyield* this.toArray();\n\t}\n\n\t/**\n\t * Data that can be resolved to give a bitfield. This can be:\n\t * * A bit number (this can be a number literal or a value taken from {@link BitField.FLAGS})\n\t * * An instance of BitField\n\t * * An Array of BitFieldResolvable\n\t * @typedef {number|BitField|BitFieldResolvable[]} BitFieldResolvable\n\t */\n\n\t/**\n\t * Resolves bitfields to their numeric form.\n\t * @param {BitFieldResolvable} [bit=0] - bit(s) to resolve\n\t * @returns {number}\n\t */\n\tstatic resolve(bit: BitFieldResolvable = BigInt(0)): bigint {\n\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t// @ts-ignore\n\t\tconst FLAGS = this.FLAGS || this.constructor?.FLAGS;\n\n\t\tif (typeof bit === \"string\") {\n\t\t\tif (typeof FLAGS[bit] !== \"undefined\") return FLAGS[bit];\n\t\t\telse bit = BigInt(bit);\n\t\t}\n\n\t\tif ((typeof bit === \"number\" || typeof bit === \"bigint\") && bit >= BigInt(0)) return BigInt(bit);\n\n\t\tif (bit instanceof BitField) return bit.bitfield;\n\n\t\tif (Array.isArray(bit)) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t\t// @ts-ignore\n\t\t\tconst resolve = this.constructor?.resolve || this.resolve;\n\t\t\treturn bit.map((p) => resolve.call(this, p)).reduce((prev, p) => BigInt(prev) | BigInt(p), BigInt(0));\n\t\t}\n\n\t\tthrow new RangeError(\"BITFIELD_INVALID: \" + bit);\n\t}\n}\n\nexport function BitFlag(x: bigint | number) {\n\treturn BigInt(1) << BigInt(x);\n}\n"],"names":["_BitField","bits","__publicField","bit","p","BIT","total","serialized","flag","_a","_b","FLAGS","resolve","prev","BitField","BitFlag","x"],"mappings":"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"}